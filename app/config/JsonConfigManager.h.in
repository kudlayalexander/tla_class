#pragma once

#include <ranges>
#include <concepts>

#include <law/File/File.h>
#include <boost/assert.hpp>
#include <rapidjson/document.h>
#include <rapidjson/prettywriter.h>
#include <Utils/Hash/CRC32/CRC32.h>
#include <magic_enum/magic_enum.hpp>
#include <static_string/static_string.h>

#include "utils/Utils.h"
#include "IConfigManager.h"
#include "utils/FileUtils.h"

#define THROW_ERROR(err, reason)                                                            \
    return newError(                                                                        \
            err,                                                                            \
            std::string_view(reason.data.data(), reason.data.size()));

#define CHECK_STRING_FIELD_LENGTH(field, type, fieldName)                                   \
    do {                                                                                    \
        if (field.GetStringLength() > type::MAX_SIZE) {                                     \
            using namespace snw1;                                                           \
            constexpr auto kErrorMessage = static_string::make(                             \
                "field with name '",                                                        \
                fieldName,                                                                  \
                "' has incorrect size: max size (",                                         \
                UTOSS(type::MAX_SIZE),                                                      \
                ")"                                                                         \
            );                                                                              \
            THROW_ERROR(                                                                    \
                    RetCode::ROM_CONFIGURATION_STRING_FIELD_LENGTH_TOO_BIG,                 \
                    kErrorMessage                                                           \
            );                                                                              \
        }                                                                                   \
    } while (false)

#define CHECK_FIELD_VALUE_RANGE_SIGNED_INTEGRAL(value, minValue, maxValue, fieldName)       \
    do {                                                                                    \
        if (value < minValue || value > maxValue) {                                         \
            using namespace snw1;                                                           \
            constexpr auto kErrorMessage = static_string::make(                             \
                    "field with name '",                                                    \
                    fieldName,                                                              \
                    "' value not in range (expected: ",                                     \
                    ITOSS(minValue),                                                        \
                    " <= val <= ",                                                          \
                    ITOSS(maxValue),                                                        \
                    ")"                                                                     \
            );                                                                              \
            THROW_ERROR(                                                                    \
                RetCode::ROM_CONFIGURATION_FIELD_VALUE_RANGE_VIOLATION,                     \
                kErrorMessage                                                               \
            );                                                                              \
        }                                                                                   \
    } while (false)

#define CHECK_FIELD_VALUE_RANGE_UNSIGNED_INTEGRAL(value, minValue, maxValue, fieldName)     \
    do {                                                                                    \
        if (value < minValue || value > maxValue) {                                         \
            using namespace snw1;                                                           \
            constexpr auto kErrorMessage = static_string::make(                             \
                "field with name '",                                                        \
                fieldName,                                                                  \
                "' value not in range (expected: ",                                         \
                UTOSS(minValue),                                                            \
                " <= val <= ",                                                              \
                UTOSS(maxValue),                                                            \
                ")"                                                                         \
            );                                                                              \
            THROW_ERROR(                                                                    \
                RetCode::ROM_CONFIGURATION_FIELD_VALUE_RANGE_VIOLATION,                     \
                kErrorMessage                                                               \
                );                                                                          \
        }                                                                                   \
    } while (false)

#define CHECK_FIELD_VALUE_RANGE_FP(value, minValue, maxValue, fieldName)                    \
    do {                                                                                    \
        if (value < minValue || value > maxValue) {                                         \
            using namespace snw1;                                                           \
            constexpr auto kErrorMessage = static_string::make(                             \
                "field with name '",                                                        \
                fieldName,                                                                  \
                "' value not in range"                                                      \
            );                                                                              \
            THROW_ERROR(                                                                    \
                RetCode::ROM_CONFIGURATION_FIELD_VALUE_RANGE_VIOLATION,                     \
                kErrorMessage                                                               \
            );                                                                              \
        }                                                                                   \
    } while (false)

#define CHECK_FIELD_VALUE_ALLOW_VALUES(value, allowValues, fieldName)                       \
    do {                                                                                    \
        if (std::ranges::find(allowValues, value) ==                                        \
                allowValues.cend()) {                                                       \
            using namespace std::literals;                                                  \
            static constexpr auto messagePartOne                                            \
                = "field with name '"sv;                                                    \
            static constexpr std::string_view fieldNameSv(fieldName);                       \
            static constexpr auto messagePartTwo                                            \
                = "' incorrect value, allow values: (expected: "sv;                         \
            static constexpr auto messagePartThree = ")"sv;                                 \
            static constexpr auto kErrorMessage =                                           \
                std::apply(                                                                 \
                    []<auto ...values>(auto ...) {                                          \
                        return utils::StrViewJoinValue<                                     \
                            messagePartOne,                                                 \
                            fieldNameSv,                                                    \
                            messagePartTwo,                                                 \
                            values...,                                                      \
                            messagePartThree                                                \
                        >;                                                                  \
                    },                                                                      \
                    std::tuple_cat(allowValues)                                             \
                );                                                                          \
            return newError(                                                                \
                RetCode::ROM_CONFIGURATION_UNEXPECTED_FIELD_VALUE,                          \
                std::string_view(kErrorMessage)                                             \
            );                                                                              \
        }                                                                                   \
    } while (false)

#define CHECK_FIELD_TYPE(method, f, fieldName, fieldValueTypename)                          \
    do {                                                                                    \
        if (!f.method()) {                                                                  \
            using namespace std::literals;                                                  \
            static constexpr auto messagePartOne                                            \
                = "field with name '"sv;                                                    \
            static constexpr std::string_view fieldNameSv(fieldName);                       \
            static constexpr auto messagePartTwo = "' has incorrect type (expected: "sv;    \
            static constexpr std::string_view fieldValueTypenameSv(fieldValueTypename);     \
            static constexpr auto messagePartThree = ")"sv;                                 \
            static constexpr auto kErrorMessage =                                           \
                utils::StrViewJoinValue<                                                    \
                    messagePartOne,                                                         \
                    fieldNameSv,                                                            \
                    messagePartTwo,                                                         \
                    fieldValueTypenameSv,                                                   \
                    messagePartThree                                                        \
                >;                                                                          \
            return newError(                                                                \
                RetCode::ROM_CONFIGURATION_INCORRECT_FIELD_TYPE,                            \
                std::string_view(kErrorMessage)                                             \
            );                                                                              \
        }                                                                                   \
    } while (false)

#define PARSE_FIELD(\
            fieldVariable, parentFieldVariable, \
            fieldName, fieldType, fieldValueTypename, fieldVariableType)                    \
    BOOST_LEAF_AUTO(&fieldVariable##Field, checkPresence(parentFieldVariable, fieldName));  \
    CHECK_FIELD_TYPE(Is##fieldType, fieldVariable##Field, fieldName, fieldValueTypename);   \
    fieldVariableType fieldVariable = fieldVariable##Field.Get##fieldType()

#define PARSE_BOOL_FIELD(fieldVariable, parentFieldVariable, fieldName)                     \
    PARSE_FIELD(fieldVariable, parentFieldVariable, fieldName, Bool, "bool", bool)

#define PARSE_STRING_FIELD(fieldVariable, parentFieldVariable, fieldName, targetFieldType)  \
    BOOST_LEAF_AUTO(&fieldVariable##Field, checkPresence(parentFieldVariable, fieldName));  \
    CHECK_FIELD_TYPE(IsString, fieldVariable##Field, fieldName, "string");                  \
    CHECK_STRING_FIELD_LENGTH(fieldVariable##Field, targetFieldType, fieldName);            \
    targetFieldType fieldVariable(                                                          \
        fieldVariable##Field.GetString(), fieldVariable##Field.GetStringLength())

#define PARSE_STRING_FIELD_CHECK_ALLOW_VALUES(\
            fieldVariable, parentFieldVariable, fieldName, targetFieldType, allowValues)    \
    PARSE_STRING_FIELD(fieldVariable, parentFieldVariable, fieldName, targetFieldType);     \
    CHECK_FIELD_VALUE_ALLOW_VALUES(                                                         \
        std::string_view(                                                                   \
            fieldVariable.data(), fieldVariable.size()), allowValues, fieldName)

#define PARSE_UINT_FIELD(fieldVariable, parentFieldVariable, fieldName)                     \
    PARSE_FIELD(fieldVariable, parentFieldVariable, fieldName, Uint, "uint", std::uint32_t)

#define PARSE_SIGNED_INTEGER_FIELD_CHECK_MIN_MAX(                                           \
            fieldVariable, parentFieldVariable,                                             \
            fieldName, minValue, maxValue, fieldType, fieldValueTypename)                   \
    PARSE_FIELD(                                                                            \
        fieldVariable, parentFieldVariable,                                                 \
        fieldName, fieldType, fieldValueTypename, decltype(maxValue));                      \
    CHECK_FIELD_VALUE_RANGE_SIGNED_INTEGRAL(fieldVariable, minValue, maxValue, fieldName)

#define PARSE_UNSIGNED_INTEGER_FIELD_CHECK_MIN_MAX(                                         \
            fieldVariable, parentFieldVariable,                                             \
            fieldName, minValue, maxValue, fieldType, fieldValueTypename)                   \
    PARSE_FIELD(                                                                            \
        fieldVariable, parentFieldVariable,                                                 \
        fieldName, fieldType, fieldValueTypename, decltype(maxValue));                      \
    CHECK_FIELD_VALUE_RANGE_UNSIGNED_INTEGRAL(fieldVariable, minValue, maxValue, fieldName)

#define PARSE_FP_FIELD_CHECK_MIN_MAX(\
            fieldVariable, parentFieldVariable, \
            fieldName, minValue, maxValue, fieldType, fieldValueTypename)                   \
    PARSE_FIELD(                                                                            \
        fieldVariable, parentFieldVariable,                                                 \
        fieldName, fieldType, fieldValueTypename, decltype(maxValue));                      \
    CHECK_FIELD_VALUE_RANGE_FP(fieldVariable, minValue, maxValue, fieldName)

#define PARSE_UINT_FIELD_CHECK_MIN_MAX(\
            fieldVariable, parentFieldVariable, fieldName, minValue, maxValue)              \
    PARSE_UNSIGNED_INTEGER_FIELD_CHECK_MIN_MAX(                                             \
        fieldVariable, parentFieldVariable, fieldName, minValue, maxValue, Uint, "uint")

#define PARSE_UINT64_FIELD_CHECK_MIN_MAX(\
            fieldVariable, parentFieldVariable, fieldName, minValue, maxValue)              \
    PARSE_UNSIGNED_INTEGER_FIELD_CHECK_MIN_MAX(                                             \
        fieldVariable, parentFieldVariable, fieldName, minValue, maxValue, Uint64, "uint64")

#define PARSE_INT_FIELD_CHECK_MIN_MAX(\
            fieldVariable, parentFieldVariable, fieldName, minValue, maxValue)              \
    PARSE_SIGNED_INTEGER_FIELD_CHECK_MIN_MAX(                                               \
        fieldVariable, parentFieldVariable, fieldName, minValue, maxValue, Int, "int")

#define PARSE_INT64_FIELD_CHECK_MIN_MAX(\
            fieldVariable, parentFieldVariable, fieldName, minValue, maxValue)              \
    PARSE_SIGNED_INTEGER_FIELD_CHECK_MIN_MAX(                                               \
        fieldVariable, parentFieldVariable, fieldName, minValue, maxValue, Int64, "int64")

#define PARSE_FLOAT_FIELD_CHECK_MIN_MAX(\
            fieldVariable, parentFieldVariable, fieldName, minValue, maxValue)              \
    PARSE_FP_FIELD_CHECK_MIN_MAX(                                                           \
        fieldVariable, parentFieldVariable, fieldName, minValue, maxValue, Float, "float")

#define PARSE_DOUBLE_FIELD_CHECK_MIN_MAX(\
            fieldVariable, parentFieldVariable, fieldName, minValue, maxValue)              \
    PARSE_FP_FIELD_CHECK_MIN_MAX(                                                           \
        fieldVariable, parentFieldVariable, fieldName, minValue, maxValue, Double, "double")

#define PARSE_OBJECT_FIELD(field, parentField, fieldName)                                   \
    BOOST_LEAF_AUTO(&field, checkPresence(parentField, fieldName));                         \
    CHECK_FIELD_TYPE(IsObject, field, fieldName, "object")

namespace config {
    class JsonConfigManager final : public IConfigManager {
    private:
        static constexpr std::string_view moduleName = "JsonConfigManager";

        static constexpr std::array<std::string_view, (std::size_t(config::Core::ModuleType::DEFAULT) + 1)>
        kModuleTypeEnumValuesAsStrings = {
#ifdef ENABLE_ZEDF9P
                "ZED_F9P",
#endif

#ifdef ENABLE_SIM68M
                "SIM68M",
#endif

#ifdef ENABLE_TAU13X2
                "TAU13X2",
#endif

#ifdef ENABLE_ST901P
                "ST901P",
#endif

#ifdef ENABLE_QM602
                "QM602",
#endif

#ifdef ENABLE_UM681A
                "UM681A",
#endif

                "DEFAULT"
        };

    private:
        using SerializedConf = CustomError<std::string>;
        using ValueRef = rapidjson::Value &;
        using ConstValueRef = const rapidjson::Value &;
        using ConstValueRefRet = CustomError<ConstValueRef>;

        using UdsUdpServerRet = CustomError<tp::UdsUdpServer>;
        using TcpServerRet = CustomError<tp::TcpServer>;
        using Rs232Ret = CustomError<tp::Rs232>;

        using ConfigRet = CustomError<Config>;

        using ApiRet = CustomError<Api>;
        using ApiTpapiRet = CustomError<Api::Tpapi>;
        using ApiGnssRet = CustomError<Api::Gnss>;
        using ApiRtcmRet = CustomError<Api::Rtcm>;
        using ApiTpapiEpRet = CustomError<Api::Tpapi::Ep>;
        using ApiGnssTransportRet = CustomError<Api::Gnss::Transport>;
        using ApiRtcmTransportRet = CustomError<Api::Rtcm::Transport>;

        using CoreRet = CustomError<Core>;
        using CoreGnssRet = CustomError<Core::Gnss>;
        using CoreRtcmRet = CustomError<Core::Rtcm>;
        using CoreImuRet = CustomError<Core::Imu>;
        using CoreGnssTransportRet = CustomError<Core::Gnss::Transport>;
        using CoreGnssPropertiesRet = CustomError<Core::Gnss::Properties>;
        using CoreRtcmTransportRet = CustomError<Core::Rtcm::Transport>;
        using CoreRtcmPropertiesRet = CustomError<Core::Rtcm::Properties>;
        using CoreRtcmPropertiesRtkModeRet = CustomError<Core::Rtcm::Properties::RtkMode>;
        using CoreRtcmPropertiesRtkModeBaseRet = CustomError<Core::Rtcm::Properties::RtkMode::Base>;
        using CoreImuPropertiesRet = CustomError<Core::Imu::Properties>;
        using CoreImuPropertiesInstallModeRet = CustomError<Core::Imu::Properties::InstallMode>;
        using CoreImuPropertiesInstallModeManualRet = CustomError<Core::Imu::Properties::InstallMode::Manual>;

        using LoggingRet = CustomError<Logging>;

    private:
        Config config;
        rapidjson::Document json;

        std::string_view confFilePath;

    public:
        explicit JsonConfigManager(std::string_view filePath) noexcept: confFilePath(filePath) {
            BOOST_ASSERT_MSG(!filePath.empty(), "configuration file path can't be null");
        }

        [[nodiscard]] const Config &getConfig() const noexcept override {
            return config;
        }

        Status apply() noexcept override {
            BOOST_LEAF_AUTO(conf, parseConfig());
            config = conf;
            return {};
        }

        Status apply(const Config &newConfig) noexcept override {
            using namespace rapidjson;
            return boost::leaf::try_handle_some(
                    [this, &newConfig]() -> Status {
                        static constexpr std::string_view kApiFieldName = "api";
                        applyApi(json[Value(kApiFieldName.data(), kApiFieldName.size())], newConfig.api);

                        static constexpr std::string_view kCoreFieldName = "core";
                        applyCore(
                                json[Value(kCoreFieldName.data(), kCoreFieldName.size())],
                                newConfig.core);

                        static constexpr std::string_view kLoggingFieldName = "logging";
                        applyLogging(
                                json[Value(kLoggingFieldName.data(), kLoggingFieldName.size())],
                                newConfig.logging);

                        config = newConfig;
                        return {};
                    }
            );
        }

        Status load() noexcept override {
            return boost::leaf::try_handle_some(
                    [this]() -> Status {
                        law::file::StaticFile<4096> confFile;
                        BOOST_LEAF_CHECK(confFile.open(confFilePath, law::file::ReadOnly()));
                        BOOST_LEAF_AUTO(fileContent, confFile.read());
                        return parse(fileContent);
                    },
                    [](law::RetCode) -> Status {
                        return newError(RetCode::ROM_CONFIGURATION_LOAD_ERROR);
                    }
            );
        }

        Status save() noexcept override {
            return boost::leaf::try_handle_some(
                    [this]() -> Status {
                        using namespace law::file;
                        File confFile;
                        BOOST_LEAF_CHECK(
                                confFile.open(
                                        confFilePath,
                                        WriteOnly() | Create(),
                                        OwnerRead() | OwnerWrite() | GroupRead() | GroupWrite()
                                )
                        );
                        BOOST_LEAF_AUTO(serializedConf, serialize());
                        BOOST_LEAF_CHECK(confFile.resize(serializedConf.size()));
                        return confFile.write(serializedConf);
                    },
                    [](law::RetCode) -> Status {
                        return newError(RetCode::ROM_CONFIGURATION_SAVE_ERROR);
                    }
            );
        }

        Status restore() noexcept override {
            return boost::leaf::try_handle_some(
                    [this]() -> Status {
                        static constexpr std::string_view kDefaultConfiguration = R"(${DEFAULT_CONFIG})";
                        BOOST_LEAF_CHECK(parse(kDefaultConfiguration));
                        saveBrokenConfigFile();
                        BOOST_LEAF_CHECK(save());
                        return apply();
                    },
                    [](law::RetCode) -> Status {
                        return newError(RetCode::ROM_CONFIGURATION_RESTORE_ERROR);
                    }
            );
        }

    private:
        Status parse(std::string_view jsonString) noexcept {
            json.Parse(jsonString.data(), jsonString.size());
            return (json.HasParseError() ? newError(RetCode::ROM_CONFIGURATION_CORRUPT) : Status());
        }

        SerializedConf serialize() noexcept {
            using namespace rapidjson;
            StringBuffer sb;

            PrettyWriter<StringBuffer> writer(sb);
            writer.SetIndent(' ', 2);
            if (!json.Accept(writer)) {
                return newError(RetCode::ROM_CONFIGURATION_SERIALIZE_ERROR);
            }

            return std::string{sb.GetString(), sb.GetSize()};
        }

        void saveBrokenConfigFile() noexcept {
            const auto [confFileDir, confFileBasename]
                    = utils::file::delimFilePathOnDirAndName(confFilePath);
            const auto brokenConfFilePath = std::string(
                    confFileDir.data(), confFileDir.size()) +
                                            "/." +
                                            std::string(confFileBasename.data(), confFileBasename.size()) +
                                            ".broken";
            rename(confFilePath.data(), brokenConfFilePath.data());
        }

        ConfigRet parseConfig() noexcept {
            PARSE_OBJECT_FIELD(apiField, json, "api");
            BOOST_LEAF_AUTO(api, parseApi(apiField));

            PARSE_OBJECT_FIELD(coreField, json, "core");
            BOOST_LEAF_AUTO(core, parseCore(coreField));

            PARSE_OBJECT_FIELD(loggingField, json, "logging");
            BOOST_LEAF_AUTO(logging, parseLogging(loggingField));

            return Config{
                    .api = api,
                    .core = core,
                    .logging = logging
            };
        }

        static void applyApi(ValueRef &apiField, const Api &api) {
            using namespace rapidjson;

            static constexpr std::string_view kTpapiFieldName = "tpapi";
            applyApiTpapi(apiField[Value(kTpapiFieldName.data(), kTpapiFieldName.size())], api.tpapi);

            static constexpr std::string_view kGnssFieldName = "gnss";
            applyApiGnss(apiField[Value(kGnssFieldName.data(), kGnssFieldName.size())], api.gnss);

            static constexpr std::string_view gRtcmFieldName = "rtcm";
            applyApiRtcm(apiField[Value(gRtcmFieldName.data(), gRtcmFieldName.size())], api.rtcm);
        }

        static void applyApiTpapi(ValueRef &tpapiField, const Api::Tpapi &tpapi) {
            using namespace rapidjson;
            static constexpr std::string_view kEpFieldName = "ep";
            applyApiTpapiEp(tpapiField[Value(kEpFieldName.data(), kEpFieldName.size())], tpapi.ep);
        }

        static void applyApiGnss(ValueRef &gnssField, const Api::Gnss &gnss) {
            using namespace rapidjson;
            static constexpr std::string_view kTransportFieldName = "transport";
            applyApiGnssTransport(
                    gnssField[Value(kTransportFieldName.data(), kTransportFieldName.size())],
                    gnss.transport);
        }

        static void applyApiRtcm(ValueRef &rtcmField, const Api::Rtcm &rtcm) {
            using namespace rapidjson;
            static constexpr std::string_view kTransportFieldName = "transport";
            applyApiRtcmTransport(
                    rtcmField[Value(kTransportFieldName.data(), kTransportFieldName.size())],
                    rtcm.transport);
        }

        static void applyApiTpapiEp(ValueRef &epField, const Api::Tpapi::Ep &ep) {
            using namespace rapidjson;
            std::visit(
                    [&epField] <typename T>(const T &tp) {
                        static constexpr std::string_view kTypeFieldName = "type";
                        auto &typeField
                                = epField[rapidjson::Value(kTypeFieldName.data(), kTypeFieldName.size())];
                        if constexpr (std::same_as<tp::UdsUdpServer, T>) {
                            static constexpr std::string_view kUdsUdpServerFieldName = "uds_udp_server";
                            typeField = Value(kUdsUdpServerFieldName.data(), kUdsUdpServerFieldName.size());

                            static constexpr std::string_view kPathFieldName = "path";
                            epField
                            [Value(kUdsUdpServerFieldName.data(), kUdsUdpServerFieldName.size())]
                            [Value(kPathFieldName.data(), kPathFieldName.size())] =
                                    Value(tp.path.data(), tp.path.size());
                        }
                    },
                    ep
            );
        }

        static void applyApiGnssTransport(ValueRef &transportField, const Api::Gnss::Transport &transport) {
            using namespace rapidjson;
            std::visit(
                    [&transportField] <typename T>(const T &tp) {
                        static constexpr std::string_view kTypeFieldName = "type";
                        auto &typeField
                                = transportField[rapidjson::Value(kTypeFieldName.data(), kTypeFieldName.size())];
                        if constexpr (std::same_as<tp::TcpServer, T>) {
                            static constexpr std::string_view kTcpServerFieldName = "tcp_server";
                            typeField.SetString(kTcpServerFieldName.data(), kTcpServerFieldName.size());
                            auto &tcpServerField =
                                    transportField[Value(kTcpServerFieldName.data(), kTcpServerFieldName.size())];

                            static constexpr std::string_view kPortFieldName = "port";
                            tcpServerField[Value(kPortFieldName.data(), kPortFieldName.size())] = Value(tp.port);
                        }
                    },
                    transport
            );
        }

        static void applyApiRtcmTransport(ValueRef &transportField, const Api::Rtcm::Transport &transport) {
            using namespace rapidjson;
            std::visit(
                    [&transportField] <typename T>(const T &tp) {
                        static constexpr std::string_view kTypeFieldName = "type";
                        auto &typeField
                                = transportField[Value(kTypeFieldName.data(), kTypeFieldName.size())];
                        if constexpr (std::same_as<tp::TcpServer, T>) {
                            static constexpr std::string_view kTcpServerFieldName = "tcp_server";
                            typeField.SetString(kTcpServerFieldName.data(), kTcpServerFieldName.size());
                            auto &tcpServerField =
                                    transportField[Value(kTcpServerFieldName.data(), kTcpServerFieldName.size())];

                            static constexpr std::string_view kPortFieldName = "port";
                            tcpServerField[Value(kPortFieldName.data(), kPortFieldName.size())] = Value(tp.port);
                        } else if constexpr (std::same_as<tp::UdsUdpServer, T>) {
                            static constexpr std::string_view kUdsUdpServerFieldName = "uds_udp_server";
                            typeField = Value(kUdsUdpServerFieldName.data(), kUdsUdpServerFieldName.size());

                            static constexpr std::string_view kPathFieldName = "path";
                            transportField
                            [Value(kUdsUdpServerFieldName.data(), kUdsUdpServerFieldName.size())]
                            [Value(kPathFieldName.data(), kPathFieldName.size())] = Value(tp.path.data(), tp.path.size());
                        }
                    },
                    transport
            );

        }

        static void applyCore(ValueRef &coreField, const Core &core) {
            using namespace rapidjson;

            const auto moduleTypeAsString = magic_enum::enum_name(core.moduleType);
            static constexpr std::string_view kModuleTypeFieldName = "module_type";
            coreField[Value(kModuleTypeFieldName.data(), kModuleTypeFieldName.size())] =
                    Value(moduleTypeAsString.data(), moduleTypeAsString.size());

            static constexpr std::string_view kGnssFieldName = "gnss";
            applyCoreGnss(
                    coreField[Value(kGnssFieldName.data(), kGnssFieldName.size())],
                    core.gnss);

            static constexpr std::string_view kRtcmFieldName = "rtcm";
            applyCoreRtcm(coreField[Value(kRtcmFieldName.data(), kRtcmFieldName.size())], core.rtcm);

            static constexpr std::string_view kImuFieldName = "imu";
            applyCoreImu(coreField[Value(kImuFieldName.data(), kImuFieldName.size())], core.imu);
        }

        static void applyCoreGnss(ValueRef &gnssField, const Core::Gnss &gnss) {
            using namespace rapidjson;

            static constexpr std::string_view kTransportFieldName = "transport";
            applyCoreGnssTransport(
                    gnssField[Value(kTransportFieldName.data(), kTransportFieldName.size())], gnss.transport);

            static constexpr std::string_view kPropertiesFieldName = "properties";
            applyCoreGnssProperties(
                    gnssField[Value(kPropertiesFieldName.data(), kPropertiesFieldName.size())], gnss.properties);
        }

        static void applyCoreRtcm(ValueRef &rtcmField, const Core::Rtcm &rtcm) {
            using namespace rapidjson;

            static constexpr std::string_view kTransportFieldName = "transport";
            applyCoreRtcmTransport(
                    rtcmField[Value(kTransportFieldName.data(), kTransportFieldName.size())], rtcm.transport);

            static constexpr std::string_view kPropertiesFieldName = "properties";
            applyCoreRtcmProperties(
                    rtcmField[Value(kPropertiesFieldName.data(), kPropertiesFieldName.size())], rtcm.properties);
        }

        static void applyCoreImu(ValueRef &imuField, const Core::Imu &imu) {
            using namespace rapidjson;

            static constexpr std::string_view kEnableFieldName = "enable";
            imuField[Value(kEnableFieldName.data(), kEnableFieldName.size())] = imu.enable;

            static constexpr std::string_view kPropertiesFieldName = "properties";
            applyCoreImuProperties(
                    imuField[Value(kPropertiesFieldName.data(), kPropertiesFieldName.size())], imu.properties);
        }

        static void applyLogging(ValueRef &loggingField, const Logging &logging) {
            loggingField["level"].SetString(logging.level.data(), logging.level.size());
        }

        static void applyCoreGnssTransport(ValueRef &transportField, const Core::Gnss::Transport &transport) {
            using namespace rapidjson;
            std::visit(
                    [&transportField] <typename T>(const T &tp) {
                        static constexpr std::string_view kTypeFieldName = "type";
                        auto &typeField
                                = transportField[Value(kTypeFieldName.data(), kTypeFieldName.size())];
                        if constexpr (std::same_as<tp::Rs232, T>) {
                            static constexpr std::string_view kRs232FieldName = "rs232";
                            typeField.SetString(kRs232FieldName.data(), kRs232FieldName.size());
                            auto &rs232Field =
                                    transportField[Value(kRs232FieldName.data(), kRs232FieldName.size())];

                            static constexpr std::string_view kDeviceFieldName = "device";
                            rs232Field[Value(kDeviceFieldName.data(), kDeviceFieldName.size())] =
                                    Value(tp.device.data(), tp.device.size());

                            static constexpr std::string_view kBaudrateFieldName = "baudrate";
                            rs232Field[Value(kBaudrateFieldName.data(), kBaudrateFieldName.size())] = Value(tp.baudrate);

                            static constexpr std::string_view kDataBitsFieldName = "data_bits";
                            rs232Field[Value(kDataBitsFieldName.data(), kDataBitsFieldName.size())] =
                                    Value(std::uint8_t(tp.dataBits));
                            const std::string_view parityValue = (
                                tp.parity == tp::Rs232::Parity::NONE ? "none" : (
                                    (tp.parity == tp::Rs232::Parity::EVEN) ? "even" : "odd")
                                );
                            static constexpr std::string_view kParityFieldName = "parity";
                            rs232Field[Value(kParityFieldName.data(), kParityFieldName.size())] =
                                    Value(parityValue.data(), parityValue.size());

                            static constexpr std::string_view kStopBitsFieldName = "stop_bits";
                            rs232Field[Value(kStopBitsFieldName.data(), kStopBitsFieldName.size())] =
                                    Value(std::uint8_t(tp.stopBits));

                            static constexpr std::string_view kFlowControlFieldName = "flow_control";
                            rs232Field[Value(kFlowControlFieldName.data(), kFlowControlFieldName.size())] =
                                    Value(bool(tp.flowControl));
                        }
                    },
                    transport
            );
        }

        static void applyCoreGnssProperties(ValueRef &propertiesField, const Core::Gnss::Properties &properties) {
            using namespace rapidjson;
            static constexpr std::string_view kNavigationSolutionRateFieldName = "navigation_solution_rate_ms";
            propertiesField[Value(kNavigationSolutionRateFieldName.data(), kNavigationSolutionRateFieldName.size())] =
                    Value(properties.navigationSolutionRate.count());
        }

        static void applyCoreRtcmTransport(ValueRef &rtcmField, const Core::Rtcm::Transport &transport) {
            using namespace rapidjson;
            std::visit(
                    [&rtcmField] <typename T>(const T &tp) {
                        static constexpr std::string_view kTypeFieldName = "type";
                        auto &typeField
                                = rtcmField[Value(kTypeFieldName.data(), kTypeFieldName.size())];
                        if constexpr (std::same_as<tp::TcpServer, T>) {
                            static constexpr std::string_view kTcpServerFieldValue = "tcp_server";
                            typeField = Value(kTcpServerFieldValue.data(), kTcpServerFieldValue.size());
                            auto &tcpServerField =
                                    rtcmField[Value(kTcpServerFieldValue.data(), kTcpServerFieldValue.size())];

                            static constexpr std::string_view kPortFieldName = "port";
                            tcpServerField[Value(kPortFieldName.data(), kPortFieldName.size())] = Value(tp.port);
                        }
                    },
                    transport
            );
        }

        static void applyCoreRtcmProperties(ValueRef &propertiesField, const Core::Rtcm::Properties &properties) {
            using namespace rapidjson;
            static constexpr std::string_view kRtkModeFieldName = "rtk_mode";
            applyCoreRtcmPropertiesRtkMode(
                    propertiesField[Value(kRtkModeFieldName.data(), kRtkModeFieldName.size())],
                    properties.rtkMode);
        }

        static void applyCoreImuProperties(ValueRef &propertiesField, const Core::Imu::Properties &properties) {
            using namespace rapidjson;
            static constexpr std::string_view kInstallModeFieldName = "install_mode";
            applyCoreImuPropertiesInstallMode(
                    propertiesField[Value(kInstallModeFieldName.data(), kInstallModeFieldName.size())],
                    properties.installMode);
        }

        static void
        applyCoreRtcmPropertiesRtkMode(ValueRef &rtkModeField, const Core::Rtcm::Properties::RtkMode &rtkMode) {
            using namespace rapidjson;
            static constexpr std::string_view kModeFieldName = "mode";
            switch (rtkMode.mode) {
                case Core::Rtcm::Properties::RtkMode::Mode::BASE: {
                    static constexpr std::string_view kBaseFieldName = "base";
                    rtkModeField[Value(kModeFieldName.data(), kModeFieldName.size())] =
                             Value(kBaseFieldName.data(), kBaseFieldName.size());
                    applyCoreRtcmPropertiesRtkModeBase(
                            rtkModeField[Value(kBaseFieldName.data(), kBaseFieldName.size())], rtkMode.base);
                    break;
                }
                case Core::Rtcm::Properties::RtkMode::Mode::ROVER: {
                    static constexpr std::string_view kModeRoverValue = "rover";
                    rtkModeField[Value(kModeFieldName.data(), kModeFieldName.size())] =
                        Value(kModeRoverValue.data(), kModeRoverValue.size());
                    break;
                }
            }
        }

        static void
        applyCoreImuPropertiesInstallMode(
                ValueRef &installModeField, const Core::Imu::Properties::InstallMode &installMode) {
            using namespace rapidjson;
            static constexpr std::string_view kModeFieldName = "mode";
            switch (installMode.mode) {
                case Core::Imu::Properties::InstallMode::Mode::MANUAL: {
                    static constexpr std::string_view kManualFieldName = "manual";
                    installModeField[Value(kModeFieldName.data(), kModeFieldName.size())] =
                             Value(kManualFieldName.data(), kManualFieldName.size());
                    applyCoreImuPropertiesInstallModeManual(
                            installModeField[Value(kManualFieldName.data(), kManualFieldName.size())], installMode.manual);
                    break;
                }
                case Core::Imu::Properties::InstallMode::Mode::AUTO: {
                    static constexpr std::string_view kModeAutoValue = "auto";
                    installModeField[Value(kModeFieldName.data(), kModeFieldName.size())] =
                        Value(kModeAutoValue.data(), kModeAutoValue.size());
                    break;
                }
            }
        }

        static void
        applyCoreRtcmPropertiesRtkModeBase(ValueRef &baseField, const Core::Rtcm::Properties::RtkMode::Base &base) {
            using namespace rapidjson;

            static constexpr std::string_view kLatFieldName = "lat";
            baseField[Value(kLatFieldName.data(), kLatFieldName.size())] = base.lat;

            static constexpr std::string_view kLonFieldName = "lon";
            baseField[Value(kLonFieldName.data(), kLonFieldName.size())] = base.lon;

            static constexpr std::string_view kAltFieldName = "alt";
            baseField[Value(kAltFieldName.data(), kAltFieldName.size())] = base.alt;
        }

        static void
        applyCoreImuPropertiesInstallModeManual(
                ValueRef &manualField, const Core::Imu::Properties::InstallMode::Manual &manual) {
            using namespace rapidjson;

            static constexpr std::string_view kXFieldName = "x";
            manualField[Value(kXFieldName.data(), kXFieldName.size())] = manual.x;

            static constexpr std::string_view kYFieldName = "y";
            manualField[Value(kYFieldName.data(), kYFieldName.size())] = manual.y;

            static constexpr std::string_view kZFieldName = "z";
            manualField[Value(kZFieldName.data(), kZFieldName.size())] = manual.z;
        }

        static ApiRet parseApi(ConstValueRef apiField) noexcept {
            PARSE_OBJECT_FIELD(tpapiField, apiField, "tpapi");
            BOOST_LEAF_AUTO(tpapi, parseApiTpapi(tpapiField));

            PARSE_OBJECT_FIELD(gnssField, apiField, "gnss");
            BOOST_LEAF_AUTO(gnss, parseApiGnss(gnssField));

            PARSE_OBJECT_FIELD(rtcmField, apiField, "rtcm");
            BOOST_LEAF_AUTO(rtcm, parseApiRtcm(rtcmField));

            return Api{
                    .tpapi = tpapi,
                    .gnss = gnss,
                    .rtcm = rtcm
            };
        }

        static CoreRet parseCore(ConstValueRef coreField) noexcept {
            PARSE_STRING_FIELD_CHECK_ALLOW_VALUES(moduleType, coreField, "module_type", etl::string<7>,
                                                  kModuleTypeEnumValuesAsStrings);

            PARSE_OBJECT_FIELD(gnssField, coreField, "gnss");
            BOOST_LEAF_AUTO(gnss, parseCoreGnss(gnssField));

            PARSE_OBJECT_FIELD(rtcmField, coreField, "rtcm");
            BOOST_LEAF_AUTO(rtcm, parseCoreRtcm(rtcmField));

            PARSE_OBJECT_FIELD(imuField, coreField, "imu");
            BOOST_LEAF_AUTO(imu, parseCoreImu(imuField));

            return Core{
                    .moduleType = magic_enum::enum_cast<Core::ModuleType>(utils::etlStringToStrView(moduleType)).value(),
                    .gnss = gnss,
                    .rtcm = rtcm,
                    .imu = imu
            };
        }

        static LoggingRet parseLogging(ConstValueRef loggingField) noexcept {
            PARSE_STRING_FIELD_CHECK_ALLOW_VALUES(level, loggingField, "level", Logging::Level,
                                                  Logging::kLevelAllowValues);
            return Logging{
                    .level = level
            };
        }

        static ApiTpapiRet parseApiTpapi(ConstValueRef tpapiField) noexcept {
            PARSE_OBJECT_FIELD(epField, tpapiField, "ep");
            BOOST_LEAF_AUTO(epValue, parseApiTpapiEp(epField));
            return Api::Tpapi{
                    .ep = epValue
            };
        }

        static ApiGnssRet parseApiGnss(ConstValueRef gnssField) noexcept {
            PARSE_OBJECT_FIELD(transportField, gnssField, "transport");
            BOOST_LEAF_AUTO(transport, parseApiGnssTransport(transportField));
            return Api::Gnss{
                    .transport = transport
            };
        }

        static ApiRtcmRet parseApiRtcm(ConstValueRef rtcmField) noexcept {
            PARSE_OBJECT_FIELD(transportField, rtcmField, "transport");
            BOOST_LEAF_AUTO(transport, parseCoreRtcmOutputTransport(transportField));
            return Api::Rtcm{
                    .transport = transport
            };
        }

        static ApiTpapiEpRet parseApiTpapiEp(ConstValueRef epField) noexcept {
            static constexpr std::string_view kUdsUdpServerFieldName = "uds_udp_server";

            BOOST_LEAF_AUTO(&type, checkPresence(epField, "type"));
            const auto typeValue = std::string_view(type.GetString(), type.GetStringLength());

            Api::Tpapi::Ep ret;
            if (typeValue == kUdsUdpServerFieldName) {
                BOOST_LEAF_AUTO(&udsUdpServerField, checkPresence(epField, kUdsUdpServerFieldName));
                BOOST_LEAF_AUTO(udsUdpServer, parseUdsUdpServer(udsUdpServerField));
                ret = udsUdpServer;
            } else {
                return newError(RetCode::ROM_CONFIGURATION_UNEXPECTED_FIELD_VALUE, typeValue);
            }

            return ret;
        }

        static ApiGnssTransportRet parseApiGnssTransport(ConstValueRef inField) noexcept {
            PARSE_STRING_FIELD(type, inField, "type", etl::string<sizeof("tcp_server") - 1>);
            switch (Utils::CRC32(utils::etlStringToStrView(type)).get()) {
                case COMPILE_TIME_CRC32_STR("tcp_server"): {
                    PARSE_OBJECT_FIELD(tcpServerField, inField, "tcp_server");
                    BOOST_LEAF_AUTO(tcpServer, parseTcpServer(tcpServerField));
                    return tcpServer;
                }
                default: {
                    return newError(RetCode::ROM_CONFIGURATION_UNEXPECTED_FIELD_VALUE, "type");
                }
            }
        }

        static ApiRtcmTransportRet parseCoreRtcmOutputTransport(ConstValueRef inField) noexcept {
            PARSE_STRING_FIELD(type, inField, "type", etl::string<sizeof("uds_udp_server") - 1>);
            switch (Utils::CRC32(utils::etlStringToStrView(type)).get()) {
                case COMPILE_TIME_CRC32_STR("tcp_server"): {
                    PARSE_OBJECT_FIELD(tcpServerField, inField, "tcp_server");
                    BOOST_LEAF_AUTO(tcpServer, parseTcpServer(tcpServerField));
                    return tcpServer;
                }
                case COMPILE_TIME_CRC32_STR("uds_udp_server"): {
                    PARSE_OBJECT_FIELD(udsUdpServerField, inField, "uds_udp_server");
                    BOOST_LEAF_AUTO(udsUdpServer, parseUdsUdpServer(udsUdpServerField));
                    return udsUdpServer;
                }
                default: {
                    return newError(RetCode::ROM_CONFIGURATION_UNEXPECTED_FIELD_VALUE, "type");
                }
            }
        }

        static CoreGnssRet parseCoreGnss(ConstValueRef gnssField) noexcept {
            PARSE_OBJECT_FIELD(transportField, gnssField, "transport");
            BOOST_LEAF_AUTO(transport, parseCoreGnssTransport(transportField));

            PARSE_OBJECT_FIELD(propertiesField, gnssField, "properties");
            BOOST_LEAF_AUTO(properties, parseCoreGnssProperties(propertiesField));

            return Core::Gnss{
                    .transport = transport,
                    .properties = properties
            };
        }

        static CoreRtcmRet parseCoreRtcm(ConstValueRef rtcmField) noexcept {
            PARSE_OBJECT_FIELD(transportField, rtcmField, "transport");
            BOOST_LEAF_AUTO(transport, parseCoreRtcmTransport(transportField));

            PARSE_OBJECT_FIELD(propertiesField, rtcmField, "properties");
            BOOST_LEAF_AUTO(properties, parseCoreRtcmProperties(propertiesField));

            return Core::Rtcm{
                    .transport = transport,
                    .properties = properties
            };
        }

        static CoreImuRet parseCoreImu(ConstValueRef imuField) noexcept {
            PARSE_BOOL_FIELD(enable, imuField, "enable");

            PARSE_OBJECT_FIELD(propertiesField, imuField, "properties");
            BOOST_LEAF_AUTO(properties, parseCoreImuProperties(propertiesField));

            return Core::Imu{
                    .enable = enable,
                    .properties = properties
            };
        }

        static CoreGnssTransportRet parseCoreGnssTransport(ConstValueRef inField) noexcept {
            PARSE_STRING_FIELD(type, inField, "type", etl::string<sizeof("rs232") - 1>);
            switch (Utils::CRC32(utils::etlStringToStrView(type)).get()) {
                case COMPILE_TIME_CRC32_STR("rs232"): {
                    PARSE_OBJECT_FIELD(rs232Field, inField, "rs232");
                    BOOST_LEAF_AUTO(rs232, parseRs232(rs232Field));
                    return rs232;
                }
                default: {
                    return newError(RetCode::ROM_CONFIGURATION_UNEXPECTED_FIELD_VALUE, "type");
                }
            }
        }

        static CoreGnssPropertiesRet parseCoreGnssProperties(ConstValueRef propertiesField) noexcept {
            PARSE_UINT_FIELD_CHECK_MIN_MAX(navigationSolutionRate, propertiesField, "navigation_solution_rate_ms",
                                           Core::Gnss::Properties::kNavigationSolutionRateMin.count(),
                                           Core::Gnss::Properties::kNavigationSolutionRateMax.count());
            return Core::Gnss::Properties{
                    .navigationSolutionRate = std::chrono::milliseconds(navigationSolutionRate)
            };
        }

        static CoreGnssTransportRet parseCoreRtcmTransport(ConstValueRef inField) noexcept {
            PARSE_STRING_FIELD(type, inField, "type", etl::string<sizeof("rs232") - 1>);
            switch (Utils::CRC32(utils::etlStringToStrView(type)).get()) {
                case COMPILE_TIME_CRC32_STR("rs232"): {
                    PARSE_OBJECT_FIELD(rs232Field, inField, "rs232");
                    BOOST_LEAF_AUTO(rs232, parseRs232(rs232Field));
                    return rs232;
                }
                default: {
                    return newError(RetCode::ROM_CONFIGURATION_UNEXPECTED_FIELD_VALUE, "type");
                }
            }
        }

        static CoreRtcmPropertiesRet parseCoreRtcmProperties(ConstValueRef propertiesField) noexcept {
            PARSE_OBJECT_FIELD(rtkModeField, propertiesField, "rtk_mode");
            BOOST_LEAF_AUTO(rtkMode, parseCoreRtcmPropertiesRtkMode(rtkModeField));

            return Core::Rtcm::Properties{
                    .rtkMode = rtkMode
            };
        }

        static CoreImuPropertiesRet parseCoreImuProperties(ConstValueRef propertiesField) noexcept {
            PARSE_OBJECT_FIELD(installModeField, propertiesField, "install_mode");
            BOOST_LEAF_AUTO(installMode, parseCoreImuPropertiesInstallMode(installModeField));

            return Core::Imu::Properties{
                    .installMode = installMode
            };
        }

        static CoreRtcmPropertiesRtkModeRet parseCoreRtcmPropertiesRtkMode(ConstValueRef rtkModeField) noexcept {
            PARSE_STRING_FIELD_CHECK_ALLOW_VALUES(
                    mode, rtkModeField, "mode", etl::string<(sizeof("rover") - 1)>,
                    Core::Rtcm::Properties::RtkMode::kModeAllowValues);

            PARSE_OBJECT_FIELD(baseField, rtkModeField, "base");
            BOOST_LEAF_AUTO(base, parseCoreRtcmPropertiesRtkModeBase(baseField));

            return Core::Rtcm::Properties::RtkMode{
                    .mode = Core::Rtcm::Properties::RtkMode::Mode(mode[0]),
                    .base = base
            };
        }

        static CoreImuPropertiesInstallModeRet parseCoreImuPropertiesInstallMode(ConstValueRef installModeField) noexcept {
            PARSE_STRING_FIELD_CHECK_ALLOW_VALUES(
                    mode, installModeField, "mode", etl::string<(sizeof("manual") - 1)>,
                    Core::Imu::Properties::InstallMode::kModeAllowValues);

            PARSE_OBJECT_FIELD(manualField, installModeField, "manual");
            BOOST_LEAF_AUTO(manual, parseCoreImuPropertiesInstallModeManual(manualField));

            return Core::Imu::Properties::InstallMode{
                    .mode = Core::Imu::Properties::InstallMode::Mode(mode[0]),
                    .manual = manual
            };
        }

        static CoreRtcmPropertiesRtkModeBaseRet parseCoreRtcmPropertiesRtkModeBase(ConstValueRef baseField) noexcept {
            PARSE_INT_FIELD_CHECK_MIN_MAX(
                    lat, baseField, "lat",
                    Core::Rtcm::Properties::RtkMode::Base::kLatMinValue,
                    Core::Rtcm::Properties::RtkMode::Base::kLatMaxValue);
            PARSE_INT_FIELD_CHECK_MIN_MAX(
                    lon, baseField, "lon",
                    Core::Rtcm::Properties::RtkMode::Base::kLonMinValue,
                    Core::Rtcm::Properties::RtkMode::Base::kLonMaxValue);
            PARSE_INT_FIELD_CHECK_MIN_MAX(
                    alt, baseField, "alt",
                    Core::Rtcm::Properties::RtkMode::Base::kAltMinValue,
                    Core::Rtcm::Properties::RtkMode::Base::kAltMaxValue);

            return Core::Rtcm::Properties::RtkMode::Base{
                    .lat = lat,
                    .lon = lon,
                    .alt = alt
            };
        }

        static CoreImuPropertiesInstallModeManualRet
        parseCoreImuPropertiesInstallModeManual(ConstValueRef manualField) noexcept {
            PARSE_INT_FIELD_CHECK_MIN_MAX(
                    x, manualField, "x",
                    Core::Imu::Properties::InstallMode::Manual::kAngleMinValue,
                    Core::Imu::Properties::InstallMode::Manual::kAngleMaxValue);
            PARSE_INT_FIELD_CHECK_MIN_MAX(
                    y, manualField, "y",
                    Core::Imu::Properties::InstallMode::Manual::kAngleMinValue,
                    Core::Imu::Properties::InstallMode::Manual::kAngleMaxValue);
            PARSE_INT_FIELD_CHECK_MIN_MAX(
                    z, manualField, "z",
                    Core::Imu::Properties::InstallMode::Manual::kAngleMinValue,
                    Core::Imu::Properties::InstallMode::Manual::kAngleMaxValue);

            return Core::Imu::Properties::InstallMode::Manual{
                    .x = x,
                    .y = y,
                    .z = z
            };
        }

        static UdsUdpServerRet parseUdsUdpServer(ConstValueRef udsUdpServerField) noexcept {
            PARSE_STRING_FIELD(path, udsUdpServerField, "path", tp::UdsUdpServer::Path);
            return tp::UdsUdpServer{
                    .path = path
            };
        }

        static Rs232Ret parseRs232(ConstValueRef rs232Field) noexcept {
            PARSE_STRING_FIELD(device, rs232Field, "device", tp::Rs232::Device);
            PARSE_UINT_FIELD_CHECK_MIN_MAX(baudrate, rs232Field, "baudrate", tp::Rs232::kBaudrateMinVal,
                                           tp::Rs232::kBaudrateMaxVal);
            PARSE_UINT_FIELD_CHECK_MIN_MAX(dataBits, rs232Field, "data_bits", tp::Rs232::kDataBitsMinVal,
                                           tp::Rs232::kDataBitsMaxVal);
            PARSE_STRING_FIELD_CHECK_ALLOW_VALUES(parity, rs232Field, "parity", etl::string<sizeof("none") - 1>,
                                                  tp::Rs232::kParityAllowValues);
            PARSE_UINT_FIELD_CHECK_MIN_MAX(stopBits, rs232Field, "stop_bits", tp::Rs232::kStopBitsMinVal,
                                           tp::Rs232::kStopBitsMaxVal);
            PARSE_BOOL_FIELD(flowControl, rs232Field, "flow_control");
            return tp::Rs232{
                    .device = device,
                    .baudrate = baudrate,
                    .dataBits = tp::Rs232::DataBits(dataBits),
                    .parity = tp::Rs232::Parity(parity[0]),
                    .stopBits = tp::Rs232::StopBits(stopBits),
                    .flowControl = tp::Rs232::FlowControl(flowControl)
            };
        }

        static TcpServerRet parseTcpServer(ConstValueRef tcpClientField) noexcept {
            PARSE_UINT_FIELD_CHECK_MIN_MAX(port, tcpClientField, "port", tp::TcpServer::kPortMinValue,
                                           tp::TcpServer::kPortMaxValue);
            return tp::TcpServer{
                    .port = port
            };
        }

        static ConstValueRefRet checkPresence(ConstValueRef field, std::string_view name) noexcept {
            const auto it =
                    field.FindMember(rapidjson::Value(name.data(), name.size()));
            if (it == field.MemberEnd()) {
                return newError(RetCode::ROM_CONFIGURATION_FIELD_NOT_PRESENCE, name);
            }
            return it->value;
        }
    };
}

#undef THROW_ERROR
#undef CHECK_STRING_FIELD_LENGTH
#undef CHECK_FIELD_VALUE_RANGE_SIGNED_INTEGRAL
#undef CHECK_FIELD_VALUE_RANGE_UNSIGNED_INTEGRAL
#undef CHECK_FIELD_VALUE_RANGE_FP
#undef CHECK_FIELD_VALUE_ALLOW_VALUES
#undef CHECK_FIELD_TYPE
#undef PARSE_FIELD
#undef PARSE_BOOL_FIELD
#undef PARSE_STRING_FIELD
#undef PARSE_STRING_FIELD_CHECK_ALLOW_VALUES
#undef PARSE_UINT_FIELD
#undef PARSE_SIGNED_INTEGER_FIELD_CHECK_MIN_MAX
#undef PARSE_UNSIGNED_INTEGER_FIELD_CHECK_MIN_MAX
#undef PARSE_FP_FIELD_CHECK_MIN_MAX
#undef PARSE_UINT_FIELD_CHECK_MIN_MAX
#undef PARSE_UINT64_FIELD_CHECK_MIN_MAX
#undef PARSE_INT_FIELD_CHECK_MIN_MAX
#undef PARSE_INT64_FIELD_CHECK_MIN_MAX
#undef PARSE_FLOAT_FIELD_CHECK_MIN_MAX
#undef PARSE_DOUBLE_FIELD_CHECK_MIN_MAX
#undef PARSE_OBJECT_FIELD
